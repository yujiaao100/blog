### 图：

#### 是什么：

#### 				节点和边的集合 G(V,E),边可以是有方向的弧 也可以是无方向的

​	节点：

​	边：无方向：

​	弧度：有方向：

​	入度：有那些点连接到这个点

​	出度：这个点连接到那些点

#### 存储：

1. 邻接矩阵： map【i】【j】 表示i，j的边
2. 邻接表：    每个顶点是一个链表 链表上放所有相连的边
3. 十字链表：     邻接表+逆序邻接表（表头有正负两个初始化指针）
4. 临街多重表： 无向图   其中一个方向用正常邻接表存 另外一个方向需要用十字链表的方式连接上节省空间 表头只有一个初始化指针  或者理解为有向图的邻接表中相同的点合并为1个（A->边13->边14   C->边13->边35 ）
5. 边集数组： 每个边的起点 终点组成一个数组 

#### 操作： 

遍历：

​	广度优先：对每个顶点进行bfs（） 并且标记访问过顶点不在重复访问（打表）

​	深度优先：对每个顶点进行dfs（） 并且标记重访问过的顶点不在重复访问（打表）

​	暴力： 双重for循环  

基本操作



各种算法;



​	最短路：

​	flody算法 简单证明

![](..\pic\graph01.png)

地杰斯特拉算法最短路径

​	假设dis【i】 是起点到 i点的最短路 每次从dis 中选择一个最短路径 取更新 所有顶点的最短路径 更新完毕

普里姆算法

​	思路非常简洁： 取一个点作为顶点 每次都取距离顶点最近的点加入集合直到没有顶点可以加入：

​	假设dis【D】为 D到结合S的最短距离 那么加入 加入C点后 最短距离为 min(dis[D],len(C,D)) //从0开始推理下

​        所以用类似弗洛伊德算开一维数组存距离即可

克鲁斯卡尔算法：

​	非常简单 将边 用边极数组排序 从小到大将每条边 使用并查集对两个顶点合并 最后得到结果就就行了



DAG（有方无环图）的拓扑排序：保证排序中前驱和后继符合图上的关系

​	方法：每次从队列里面选择一个入度为0的点  弹出 去掉(这是一个结果) 减少其点的入度 （广度优先搜索+减少点的入度）

​	可以用栈