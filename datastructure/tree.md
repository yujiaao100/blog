树和森林

##### 基础概念：

​	高度：

​	左子树 ：

​	右子树：

​	父节点：

​	阶： max孩子节点数量

##### 存储：

​	1.使用左右指针存储

​	2.开一个数组左右指针都是数字//和指针一样 只是用int模拟指针 提前预留空间 方便处理

​	3.开一个数组存父节点下标  

​	4.线索二叉树：

​     	使用空指针 左侧表示的是 前驱  右侧表示后继

没有空指针怎么办（中间节点）  中间节点中序遍历 前驱就是左侧  后继就是右侧

这种情况下 中序 二叉树就是一个双向链表 所有顶点的前驱和后继都可以找到

​	5.用一个长度为 2^n-1 的数组连续存储满二叉树 左子树就是 2n+1 右子树就是2n+2 甚至可以开结构体记录父节点（浪费存储空间 但是为所欲为了 怎么查速度都不慢）

##### 基础操作：

​	先序遍历：递归（栈）实现

​	中序遍历：递归（栈）实现

​	后续遍历：递归（栈）实现

​	按照层遍历：队列实现

​	左旋转：根节点像右移动  左侧子树所有节点高度+1 右侧子树所有节点高度-1

​	右旋转：根节点像左移动 左侧子树高度-1 右侧高度+1

##### 特殊的树和应用：

##### 	森林：

​	 	左孩子右兄弟表示法

​		左侧孩子用一个数组表示左右的点 每个点用一个链表表示兄弟 （强行给所有点排序产生一个数组 每个数组都是这个点的兄弟链表 感觉像是邻接表的存储）

​		父亲节点表示法： 一维数组存放每个节点的父节点

##### 	并查集： 使用一个数组存父节点下标 形成一颗树

​		初始化：每个点的坐标和初始化值相等表示自己和自己一个组

​		然后又两个操作 

​		查找：循环或者递归查找到最开始的父节点（结束条件是自己等于自己）

​		合并 找到两个顶点并且修改一致的

​		优化  递归查找的时候进行将第三层甚至更多层的数据更新到第一层父节点

##### 	平衡二叉排序树:

##### 		平衡：左右子树高度差别为+1 -1 或者0

​		排序：左子树的点一定小于等于根节点 右侧一定大于根节点	

​		删除：从左子树中找到一个最大的点（左子树 像右搜索） 或者从右子树向左搜索（二选一  不过可以入股没有左侧选右侧）

​		插入：判断大小应该放在左侧还是右侧 调整旋转（普通排序可以不旋转）

​		中序遍历出来就是一个有序数组（无论平和排序还是普通排序）

​		有序表抽象成二叉排序查找树的方向如下： 

​	        1234567           4

​					2    6

​                                      13   5 7

​	       对比： 有序链表无法二分查找  插入的时间复杂度为 O(1)

​			    有序动态数可以二分查找 二分插入 但是插入的时候除了查找的O（logn） 还需要 O（n-logn） 次的移动复杂度高  而且vector这种 空间不够就*2的数据结构很浪费空间 

​		题外话：算法是时间和空间的 trade off  

##### 	堆：

​		一颗满二叉树： 所有元素按照层顺序排列  1 2 3 4 5.。。 最后右剩余空间

​		假如有一个 10个数的数组 那么就是强行让 a【1】 是 a【0】的左子树 a【2】是右子树 以此类推 将一个数组整个从上到下 从左向右堆放在一个堆里面

​		大根堆和小根堆：保证父节点的元素大于等于或者小于等于子节点 

  		调整方法：

​		从下向上 从左像右 将小的顶点或者大的顶点向上冒泡 交换

​		堆排序：

​				n个元素的数组a[n-1] 建立堆 每次用建立堆的方式得到最大值 （时间复杂度 logn）

​				将最大值和最后一个元素交换 前面在进行一次建立大根堆操作  		

##### 	哈夫曼树：

​		给左右子树加上权值 左侧权值小于右侧权值的树

​		特殊哈夫曼编码：左侧权值是0 右侧权值1 节点可以存放父节点的边的权值组成的编码



##### 	b树多路平衡查找树 

​		终端节点：倒数第二层节点：b树不包括最后一层的叶子节点 可以理解为他们都是空的（严书定义）

​		满足性质的m叉树：

​		（1） 书中每个节点最多有m棵子树（废话 m叉树）

​                （2） 根节点如果不是终端节点 至少两个子树（除非只有一个节点 否则至少有两棵子树）

​		（3） 除了根节点以外所有节点都至少有 [m/2] 棵子树 （至少半满  保证接近于半满插入删除很方便）

​                 （4） 叶子节点在同一层 不带信息

​		 （5） 假如孩子节点有n个 n-1个是关键字 关键字有序 使用n-1个关键字对整个数轴进行分割 则孩子节点 的关键字的值c[x]一定在 p[x],p[x-1]之间

​		  另一种抽象 Max个点按照顺序排列在数轴上 取m1个点对他们进行分割然后在将m1排列取得m2个点在进行分割直到分割到最后就剩下3个点1个点使得高度平衡  或者说选出一部分元素左挡板 有一个参数m阶 也就是最多有m个坑连着

​		一个元素是板子还是坑 取决于左右元素 板子的左右元素都是坑（假如一侧没有不行 要是板子连续也不行）

​		 插入：假如插入的是坑 插入后考虑坑是否大于m 大于的话选一个左板子分割

​			并不能插入板子 因为没法知道那个数是板子 必须和坑比较之后才能拿出来板子

​		删除：删除板子 坑相连 长度过大的话悬一个当板子 删除坑 上层板子变成坑和后面的坑相连 如果坑过大 则选一个做板子 

​	

##### b+树（mysql 的索引）

​	和b树不同：

​		   存储： 每个节点的所所有子节点的权值都用来表示子节点的最大值 （b树 其中一个表示数目 其他表示关键字 父关键字和子关键字没有指定关系）

​                   终端节点增加指针使用链表链接

​		   孩子指针权值 （关键字） 有序

​		另外一种抽象：将一个数组或者链表分块，每一块取得最大值然后排序对到上一层，继续分块取得最大值，直到最后就剩一个顶点（2个以上的关键字作为范围）

​	 	终端节点就是数据的全排列 上面都是索引： 查询的时候返回索引 插入的时候要插入索引和终端节点





快读排序（从小到大）：

方法1：以a【0】 为基准p存储上 右侧找到一个小于p的 左侧在找到一个大于p的数字进行交换直到左右相等都为X  那么x就是a0应该在的位置 交换过去 然后拍a【x】的左侧和右侧 

方法2：a【0】为基准p  右侧找到一个小于p的点 把a【0】 塞过去