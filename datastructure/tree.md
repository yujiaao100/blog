树和森林

##### 基础概念：

​	高度：

​	左子树 ：

​	右子树：

​	父节点：

##### 存储：

​	1.使用左右指针存储

​	2.开一个数组左右指针都是数字//和指针一样 只是用int模拟指针 提前预留空间 方便处理

​	3.开一个数组存父节点下标  

​	4.线索二叉树：

​     	使用空指针 左侧表示的是 前驱  右侧表示后继

没有空指针怎么办（中间节点）  中间节点中序遍历 前驱就是左侧  后继就是右侧

这种情况下 中序 二叉树就是一个双向链表 所有顶点的前驱和后继都可以找到

​	5.用一个长度为 2^n-1 的数组连续存储满二叉树 左子树就是 2n+1 右子树就是2n+2 甚至可以开结构体记录父节点（浪费存储空间 但是为所欲为了 怎么查速度都不慢）

##### 基础操作：

​	先序遍历：递归（栈）实现

​	中序遍历：递归（栈）实现

​	后续遍历：递归（栈）实现

​	按照层遍历：队列实现

​	左旋转：根节点像右移动  左侧子树所有节点高度+1 右侧子树所有节点高度-1

​	右旋转：根节点像左移动 左侧子树高度-1 右侧高度+1

##### 特殊的树和应用：

##### 	森林：

​	 	左孩子右兄弟表示法

​		左侧孩子用一个数组表示左右的点 每个点用一个链表表示兄弟 （强行给所有点排序产生一个数组 每个数组都是这个点的兄弟链表 感觉像是邻接表的存储）

​		父亲节点表示法： 一维数组存放每个节点的父节点

##### 	并查集： 使用一个数组存父节点下标 形成一颗树

​		初始化：每个点的坐标和初始化值相等表示自己和自己一个组

​		然后又两个操作 

​		查找：循环或者递归查找到最开始的父节点（结束条件是自己等于自己）

​		合并 找到两个顶点并且修改一致的

​		优化  递归查找的时候进行将第三层甚至更多层的数据更新到第一层父节点

##### 	平衡二叉排序树:

##### 		平衡：左右子树高度差别为+1 -1 或者0

​		排序：左子树的点一定小于等于根节点 右侧一定大于根节点	

​		删除：从左子树中找到一个最大的点（左子树 像右搜索） 或者从右子树向左搜索（二选一  不过可以入股没有左侧选右侧）

​		插入：判断大小应该放在左侧还是右侧 调整旋转（普通排序可以不旋转）

​		中序遍历出来就是一个有序数组（无论平和排序还是普通排序）

​		有序表抽象成二叉排序查找树的方向如下： 

​	        1234567           4

​					2    6

​                                      13   5 7

​	       对比： 有序链表无法二分查找  插入的时间复杂度为 O(1)

​			    有序动态数可以二分查找 二分插入 但是插入的时候除了查找的O（logn） 还需要 O（n-logn） 次的移动复杂度高  而且vector这种 空间不够就*2的数据结构很浪费空间 

​		题外话：算法是时间和空间的 trade off  

##### 	堆：

​		一颗满二叉树： 所有元素按照层顺序排列  1 2 3 4 5.。。 最后右剩余空间

​		假如有一个 10个数的数组 那么就是强行让 a【1】 是 a【0】的左子树 a【2】是右子树 以此类推 将一个数组整个从上到下 从左向右堆放在一个堆里面

​		大根堆和小根堆：保证父节点的元素大于等于或者小于等于子节点 

  		调整方法：

​		从下向上 从左像右 将小的顶点或者大的顶点向上冒泡 交换

​		堆排序：

​				n个元素的数组a[n-1] 建立堆 每次用建立堆的方式得到最大值 （时间复杂度 logn）

​				将最大值和最后一个元素交换 前面在进行一次建立大根堆操作  		

##### 	哈夫曼树：

​		给左右子树加上权值 左侧权值小于右侧权值的树

​		特殊哈夫曼编码：左侧权值是0 右侧权值1 节点可以存放父节点的边的权值组成的编码



##### 	b树 和b+树：



快读排序（从小到大）：

方法1：以a【0】 为基准p存储上 右侧找到一个小于p的 左侧在找到一个大于p的数字进行交换直到左右相等都为X  那么x就是a0应该在的位置 交换过去 然后拍a【x】的左侧和右侧 

方法2：a【0】为基准p  右侧找到一个小于p的点 把a【0】 塞过去