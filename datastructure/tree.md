树和森林

##### 基础概念：

​	高度：

​	左子树 ：

​	右子树：

​	父节点：

​	阶： max孩子节点数量

##### 存储：

​	1.使用左右指针存储

​	2.开一个数组左右指针都是数字//和指针一样 只是用int模拟指针 提前预留空间 方便处理

​	3.开一个数组存父节点下标  

​	4.线索二叉树：

​     	使用空指针 左侧表示的是 前驱  右侧表示后继

没有空指针怎么办（中间节点）  中间节点中序遍历 前驱就是左侧  后继就是右侧

这种情况下 中序 二叉树就是一个双向链表 所有顶点的前驱和后继都可以找到

​	5.用一个长度为 2^n-1 的数组连续存储满二叉树 左子树就是 2n+1 右子树就是2n+2 甚至可以开结构体记录父节点（浪费存储空间 但是为所欲为了 怎么查速度都不慢）

##### 基础操作：

​	先序遍历：递归（栈）实现

​	中序遍历：递归（栈）实现

​	后续遍历：递归（栈）实现

​	按照层遍历：队列实现

​	左旋转：根节点像右移动  左侧子树所有节点高度+1 右侧子树所有节点高度-1

​	右旋转：根节点像左移动 左侧子树高度-1 右侧高度+1

##### 特殊的树和应用：

##### 	森林：

​	 	左孩子右兄弟表示法

​		左侧孩子用一个数组表示左右的点 每个点用一个链表表示兄弟 （强行给所有点排序产生一个数组 每个数组都是这个点的兄弟链表 感觉像是邻接表的存储）

​		父亲节点表示法： 一维数组存放每个节点的父节点

##### 	并查集： 使用一个数组存父节点下标 形成一颗树

​		初始化：每个点的坐标和初始化值相等表示自己和自己一个组

​		然后又两个操作 

​		查找：循环或者递归查找到最开始的父节点（结束条件是自己等于自己）

​		合并 找到两个顶点并且修改一致的

​		优化  递归查找的时候进行将第三层甚至更多层的数据更新到第一层父节点

##### 	平衡二叉排序树:

##### 		平衡：左右子树高度差别为+1 -1 或者0

​		排序：左子树的点一定小于等于根节点 右侧一定大于根节点	

​		删除：从左子树中找到一个最大的点（左子树 像右搜索） 或者从右子树向左搜索（二选一  不过可以入股没有左侧选右侧）

​		插入：判断大小应该放在左侧还是右侧 调整旋转（普通排序可以不旋转）

​		中序遍历出来就是一个有序数组（无论平和排序还是普通排序）

​		有序表抽象成二叉排序查找树的方向如下： 

​	        1234567           4

​					2    6

​                                      13   5 7

​	       对比： 有序链表无法二分查找  插入的时间复杂度为 O(1)

​			    有序动态数可以二分查找 二分插入 但是插入的时候除了查找的O（logn） 还需要 O（n-logn） 次的移动复杂度高  而且vector这种 空间不够就*2的数据结构很浪费空间 

​		题外话：算法是时间和空间的 trade off  

##### 	堆：

​		一颗满二叉树： 所有元素按照层顺序排列  1 2 3 4 5.。。 最后右剩余空间

​		假如有一个 10个数的数组 那么就是强行让 a【1】 是 a【0】的左子树 a【2】是右子树 以此类推 将一个数组整个从上到下 从左向右堆放在一个堆里面

​		大根堆和小根堆：保证父节点的元素大于等于或者小于等于子节点 
		新建堆方法：

​				从后向前 从下向上调整这个元素和父元素的大小关系（倒着来）

​				先是 右节点和父亲比较交换 （右孩子 父亲）

​				然后左侧节点和父亲比较（做孩子  min（父亲，右孩子））

​				最后得到的顺序一定是根《做孩子《右孩子				

  		调整方法：

​				从上到下从左到右调整  logn 

​		堆排序：

​				建立堆

​				堆顶和最后一个元素交换  交换后最后一个元素就不在属于堆 堆得大小-1

​				调整堆

​				直到结束

##### 	哈夫曼树：

​		带权值路径最小的树：

​		构建方法：

​			假设n个叶子节点的权值为w【0】~w【n-1】

​			将权值记录在叶子节点上 然后选两个最低的节点合并成一个树 产生新节点的权值就是两个节点的和 然后将这个节点参与比较 去掉两个子树 然后将根参与比较

​			底层实现 在数组 w【】 前面在开一个相同大小的数组 t【】  t的尾部指针q 每次合并都放入t数组尾部  一个辅助bool数组 s 记录所有节点是否被选择过   初始从w里面选两个最小的和和t的尾部合并  q左移动

​		然后再从t的尾部 和w没选过的选2个合并 q继续移动 循环 直到结束

​		 

​		特殊哈夫曼编码：左侧权值是0 右侧权值1 节点可以存放父节点的边的权值组成的编码



##### 	b树多路平衡查找树 

​		终端节点：倒数第二层节点：b树不包括最后一层的叶子节点 可以理解为他们都是空的（严书定义）

​		满足性质的m叉树：

​		（1） 书中每个节点最多有m棵子树（废话 m叉树）

​                （2） 根节点如果不是终端节点 至少两个子树（除非只有一个节点 否则至少有两棵子树）

​		（3） 除了根节点以外所有节点都至少有 [m/2] 棵子树 （至少半满  保证接近于半满插入删除很方便）

​                 （4） 叶子节点在同一层 不带信息

​		 （5） 假如孩子节点有n个 n-1个是关键字 关键字有序 使用n-1个关键字对整个数轴进行分割 则孩子节点 的关键字的值c[x]一定在 p[x],p[x-1]之间

​		  另一种抽象 Max个点按照顺序排列在数轴上 取m1个点对他们进行分割然后在将m1排列取得m2个点在进行分割直到分割到最后就剩下3个点1个点使得高度平衡  或者说选出一部分元素左挡板 有一个参数m阶 也就是最多有m个坑连着

​		一个元素是板子还是坑 取决于左右元素 板子的左右元素都是坑（假如一侧没有不行 要是板子连续也不行）

​		 插入：假如插入的是坑 插入后考虑坑是否大于m 大于的话选一个左板子分割

​			并不能插入板子 因为没法知道那个数是板子 必须和坑比较之后才能拿出来板子

​		删除：删除板子 坑相连 长度过大的话悬一个当板子 删除坑 上层板子变成坑和后面的坑相连 如果坑过大 则选一个做板子 

​	

##### b+树（mysql 的索引）

​	和b树不同：

​		   存储： 每个节点的所所有子节点的权值都用来表示子节点的最大值 （b树 其中一个表示数目 其他表示关键字 父关键字和子关键字没有指定关系）

​                   终端节点增加指针使用链表链接

​		   孩子指针权值 （关键字） 有序

​		另外一种抽象：将一个数组或者链表分块，每一块取得最大值然后排序对到上一层，继续分块取得最大值，直到最后就剩一个顶点（2个以上的关键字作为范围）

​	 	终端节点就是数据的全排列 上面都是索引： 查询的时候返回索引 插入的时候要插入索引和终端节点

胜者树：

​		一颗完全二叉树：（数组实现）

​		最底下一层是数据 上面是数据是地下数据两个人1组pk获得的结果

​		和堆区别：

​			1.存储：堆得每个节点都用来存数据了 而胜者树就是下面一层是数据 上面都是存的竞争结果：

​			2.时间效率：建立效率基本相同 但是调整 胜者树是下到上 每次只是比较兄弟节点大小填充到父节点 堆是从上到下 和2孩子节点比较大小每个一次找到位置然后继续

败者树：

​		完全二叉树：数组实现：

​		每个上层节点存失败者 编号

​		更新的时候用用父节点缓存成功者 最后头结点前面一个节点编号

​		假如数组长度为n：

​		两个有意思的结论：

##### 		1.整个树不算叶子节点的总节点个数是n-1  正好用 一个长度为n数组ls存放整个败者树+最后结果 

​		（假设2^x<num<=2^(x+1)  而前面的和 sum=2^(n+1)-1  带入 得到 num<=sum+1   而num>sum 如果不是 那么没法切好排列在低x层  因此num-sum=1 ）



2. 父节点编号为f  左子树编号为2f  右侧子节点编号为 2f+1 （定义） 但是 如果非叶子最后一层节点的子节点 那么在最后结果里面  将base（b）数组放置在ls【败者树】后面那么 b【0】=ls【n】 b【1】=ls【n+1】 b【2】=ls【n+2】	

   则ls【X】=b【X-n】

      左子树 ls【2f】=b【2f-n】 我们假设左子树坐标为s1  则s1=2f-n

      右子树  ls【2f】=b【2f-n+1】 我们假设右子树坐标为S2 则S2=2f-n+1   （向下取得整数）

   变形：f=（s+n）/2

   

   调整：和胜者树一样 去掉最终胜利者后 可以从下向上调整 每次和父节点比较  每次父节点都是可能的胜利者 	如果该点比父节点大 则和父节点交换直到和0交换   每一个元素的父节点都是本轮比赛的获胜者

   新建树：让最开始左右节点都是失败者（也就是失败者的可能最小值）

   ​		然后从右向左对所有外部节点进行调整（当然也可以从前向后 但是从后向前符合用数组表示树思考的习惯）

   ​		