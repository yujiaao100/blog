快读排序：

1选择一个元素 移动该元素位置 使得左侧都比这个元素小 右侧都比这个元素大 那么久固定了这个元素的位置  然后递归排序左侧和右侧数组

​	一趟排序方法：

​	方法1：  让第一个点为 p （p=a【left】）

​		从右向左找到第一个比p小的点（右侧有问题点）

​		然后在从左侧找到比p大的点（左侧有问题点）

​		交换两个点 继续循环 （为什么交换 因为找到这交换后满足左侧逗比p小 右侧都比p大的条件）

​		直到左侧和右侧相等

​		将p【0】和他交换

​	方法2：

​		让第一个点为 p （p=a【left】)   

​               // 将a[left] 隐藏式赋值为坑（代码没有方便理解） 或者直接给a [left] 叫做 a[坑]

​		从右侧像左侧循环 找到第一个比p小的点 

​                 将坑赋值为 a[right]  这是 坑就是a【right】

​		从错侧循环到第一个比p大的点

​		将坑赋值为a【left】 成功转移

​		如此循环 直到左侧右侧相等 那么坑的位置就可以填p数字了 



排序方法集合：

​	n*2 时间复杂度： 

​	冒泡：

​	选择：

​	

​	堆排序：

​	快读： 

​	归并：

​	希尔： 选择 a【0】  a[0]+n a[0]++2n 进行插入排序 然后缩小n 直到有序（希尔自己提出的是每次减少一半）

​	

​	不排序： 

​		放hash顺序输出（hash算法保证有顺序） 冲突处理：

​		hash后每个点方三个数据：是否存在这个数字 	 只有一个和 有多个的情况下的下一个空节点

​							     找一个数组中不存在的数字（-1） 本身编号   下一个空桶编号

​			抽象理解：n个球放在m个空桶（m>n） 如果桶满了 那么找下一个空桶那么放在下一个空桶里面 或者将里面的球放在下一个空桶里面

​			一个数组 每个元素都是空或者链表 然后将左右链表的元素压平到数组的的地方

​		节省空间： 

​	桶排序： 

​	基数： 高位优先：分支递归（先比较高位 在比较地位 和人的思考方式一样 先比百位 在比较十位数）

​		    低位优先： 从低到高 对数据进行hash排序 

​	