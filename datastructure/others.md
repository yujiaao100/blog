快读排序：

1选择一个元素 移动该元素位置 使得左侧都比这个元素小 右侧都比这个元素大 那么久固定了这个元素的位置  然后递归排序左侧和右侧数组

​	一趟排序方法：

​	方法1：  让第一个点为 p （p=a【left】）

​		从右向左找到第一个比p小的点（右侧有问题点）

​		然后在从左侧找到比p大的点（左侧有问题点）

​		交换两个点 继续循环 （为什么交换 因为找到这交换后满足左侧逗比p小 右侧都比p大的条件）

​		直到左侧和右侧相等

​		将p【0】和他交换

​	方法2：

​		让第一个点为 p （p=a【left】)   

​               // 将a[left] 隐藏式赋值为坑（代码没有方便理解） 或者直接给a [left] 叫做 a[坑]

​		从右侧像左侧循环 找到第一个比p小的点 

​                 将坑赋值为 a[right]  这是 坑就是a【right】

​		从错侧循环到第一个比p大的点

​		将坑赋值为a【left】 成功转移

​		如此循环 直到左侧右侧相等 那么坑的位置就可以填p数字了 



排序方法集合：

​	n*2 时间复杂度： 

​	冒泡：

​	选择：

​	插入：

​		

​	

​	特殊：

​	希尔： 选择 a【0】  a[0]+n  a[0]++2n 进行插入排序 然后缩小n 直到有序（希尔自己提出的是每次减少一半）  时间小于 O(n*2) 最佳时间复杂度可能到 O(n^1.3)   和 n区间的小选择有关 区间为1的时候就是普通插入排序 O(n*2) n为 {2,1}  的时候 2的时候 就是 O((n/2)^2*2)=O(n^2/2) n等于1的时候每个元素只需要比较1至2次便可插入排序完成 

​	另一种抽象： 将一个数组看成n段 每段插入排序 排序好了之后 将每一段的第一个元素 放在一起 元素放在一起 一次类推 n不断减小 数组变得有顺序

​	

​	时间复杂度 n*logn

​	堆排序：	建立堆 交换堆顶和最后一个元素 然后调整堆

​	快读：    每次选择一个元素放到合适位置上（左侧都比他小 右侧都比他大） 然后递归

​	归并： 	递归的形式将数组不停的分 每次分成几个组用插入排序对他们进行排序 直到最后，每一趟归并时间复杂度为n  需要logn次归并 时间复杂度就是nlogn

​	折半插入： 每次插入的时候比较数字都和一半比较（有序数组是能取得1半 O（1））

​		



​		

​	不排序： 

​		放hash顺序输出（hash算法保证有顺序） 冲突处理：

​		方案1：直接计数

​		方案2：hash后每个点方三个数据：是否存在这个数字 	 只有一个和 有多个的情况下的下一个空节点

​							     找一个数组中不存在的数字（-1） 本身编号   下一个空桶编号

​			抽象理解：n个球放在m个空桶（m>n） 如果桶满了 那么找下一个空桶那么放在下一个空桶里面 或者将里面的球放在下一个空桶里面

​			一个数组 每个元素都是空或者链表 然后将左右链表的元素压平到数组的的地方

​		节省空间： 

​	桶排序： 

​	基数： 高位优先：分支递归（先比较高位 在比较地位 和人的思考方式一样 先比百位 在比较十位数）

​		    低位优先： 从低到高 一次对数据进行hash排序 （可以做优化 存放下一个点的位置 可以不优化）

​	

外部排序：

​	多路归并排序：	

​		两个1M的有序数组进行合并 内存只有 2*10KB+1KB（输入缓存+输出缓存）  时候  每次从两个数组里面取得10KB 进行归并 到1KB满了就写文件

​		抽象：两个队列 每次取得最大值落入盒子中盒子满了盒子里面的数字有序 然后将盒子内容推送到文件中 

​		可以进行多路归并 使用败者树优化 

​	置换-选择排序生成初始合并段





KMP：

​	 next数组 ： 

​	//假设p串 里面有一个子串p0~pi  有一个K  让p0~pk   p{i-k+1） 到pi 相等 k的最大值

   	假设字符串p【i】 是p的一个子串   p0~p【i】  p【0】~p【k】   p【i-k+1】~p【i】 是 p【i】的两个子串

​	就是以 s【0】 开头的一个和 以s【i】 结尾的两个长度一样的子串 求k的最大值

​	我们假设 next【0】=-1	表示不存在

​	

​	求解方法 如果  

​	另：p[i]=X   j=next[i-1]

​	那么情况就是 p【0】~p【j】  和  p【i-（j+1）+1】，p【i-1】 一定完全相同 而且是最长的 那么在两个最长的序列后面天上一个 如果相等 那么长度+1 如果不相等 j向前循环 直到相等 此时 j=next【j】 （看看next【next【j】】的定义）如果没有就继续 直到结束

​	KMP算法 就是每次一边匹配 一边求next数组 如果不能匹配  那么模式串的指针不退回0  而是退回到next值+1



外部排序：

​	内存不足的情况下排序 大多数排序方法都不适用 归并排序可以将在小块归并的时候可以在两个链表上 1小块 1小块的读入进入缓冲区 

​	n路归并

​	n路归并选择最值得时候可以使用败者树增加速度（n个数选择最优 选了之后补充一个再选）

​	置换选择算法

​	n路归并每一路的初始序列 可以用一个堆或者胜者树 败者树之类的数据结构 的进行优化：

​	给一个初始优先队列每次弹出队头元素  然后进入元素的时候判断这个元素是否比弹出元素小 如果小 一定不能是最后输出元素因为和前面顺序不一致 则剔除队列 最后一位放置在第一位的位置 该元素放置在数组最后一位 数组减少1 这样循环直到数组长度为0 产生一个输出  然后利用不用的数字禅城新的败者树（堆 胜者树）一次类推

​	使用推可以节省内存让一次性读入更多数据进行操作（一次能读100M 使用1M的堆 一次可以分99M 数据 而如果使用败者树那么一次使用2M空间 可以分98M数据）

​	最佳归并树---哈夫曼树保证每个叶子节点权值最小