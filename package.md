#### 由背包问题的讨论

##### 0-1背包

问题描述：

有n件物品，没见物品的重量为w【i】，价值为c【i】现在需要选择若干物品放入一个容量为v的背包中 ，使得在选入背包内物品重量不少过容量V的前提下，让背包中的物品的价值最大。求最大值



5 8                  //5件物品

3 5 1 2 2         //重量

4 5 2 1 3          //价值



完全不优化方法：

抽象方法1： 每一个物品选不选为0 1 那么 00001  00010 00011 等等代表选择序列 这种序列用二进制描述是连续的  只要循环 0~(2^n-1) 这 2^n 个顶点即可 即可 得到所有结果



抽象方法2： 抽象成一个树(霍夫曼树) 每一层代表一个节点  左右代表选不选该节点  （选了就是1 不选就是0）最后一层是结果  那么和方法1 结果相同 都是只要最后一层节点的值 在节点上做先序遍历DFS搜索即可  （图很丑无视）



![](C:\Users\yujiaao100\Desktop\mydoc\pic\package1.png)



优化1：超重处理





​	方法2 超重处理：

​	如果右子树超重 那么直接砍掉不遍历  只是遍历左子树

 

​	方法1 超重处理： 左侧变为1打表（空间复杂福高）

​	00001011 超重 那么00011011 也超重 0011 1011 也超重  打hash表 2^n 空间复杂度 无法接受

​	方法1 无效优化：

​	00001011 是最大值 那么 00000011 一定不是最大值 标记 去掉一个1 数字会变小 从小到大遍历的话小的数字已经遍历过了     假如反过来遍历 11111111 11111110 那么超重处理无效（因为前面计算过了）



​	

优化2： 记录

​	

​	方法2 中 使用二位数组  dp【i】【v】 来记录 达到 i个元素 重量为v时候的最大cost（ 将树靠在左侧形成一个下三角矩阵 竖着是层级 横着是第几个 因为第几个无法取得 因此按照到这个节点的总重量重量排序 总重量相同的 取价值大的 价值小的不要了）

​      状态转移方程 dp【i】【v】=max（dp【i-1】【v】，dp【i】【v-w【i】】+c【i】） 填表即可

![](C:\Users\yujiaao100\Desktop\mydoc\pic\package2.png)



优化3 滚动数组：后面再说